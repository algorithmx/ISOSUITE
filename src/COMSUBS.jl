
function comsubs_block(
    cif_fn
    )
    IT = get_symmetry_Int_Tables_number(cif_fn)
    (a, b, c, alpha, beta, gamma) = get_cell_params(cif_fn)
    atom_pos = extract_atom_config(cif_fn)
    # the improved cif from findsym has fixed order :
    # _atom_site_label
    # _atom_site_type_symbol
    # _atom_site_symmetry_multiplicity
    # _atom_site_Wyckoff_label
    # _atom_site_fract_x
    # _atom_site_fract_y
    # _atom_site_fract_z
    # _atom_site_occupancy
    # _atom_site_fract_symmform
    wk(s) = match(r"\s+[a-n]\s+(-)?\d+\.\d+\s+(-)?\d+\.\d+\s+(-)?\d+\.\d+",s).match
    am(s) = SPLTS(s)[2]
    wyck_lines = ["$a  $w" for (a,w) in zip(am.(atom_pos), wk.(atom_pos))]
    return [
        [ "$IT   ! space group symmetry ",
          (strip((@sprintf "%12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f"  a  b  c  alpha  beta  gamma)) 
          * "   ! lattice parameters: a,b,c,alpha,beta,gamma"),
          "$(length(wyck_lines))   ! number of Wyckoff positions"
        ];
        wyck_lines
    ]
end


function comsubs_input(
    cif1_fn::AbstractString, 
    cif2_fn::AbstractString;
    title = "generated by comsub_input",
    size = 4,
    strain = (0.95,1.05),
    shuffle = 1.5,
    neighbor = 0.0,
    subgroup = (1,230)
    )
    return [
        [title,];
        comsubs_block(  cif1_fn  );
        comsubs_block(  cif2_fn  );
        [
            (@sprintf "size         %d" size),
            (@sprintf "strain     %8.4f  %8.4f" strain[1] strain[2]),
            (@sprintf "shuffle    %8.4f" shuffle),
            (@sprintf "neighbor   %8.4f" neighbor),
            (@sprintf "subgroup     %d  %d" subgroup[1] subgroup[2]),
        ];
    ]
end


function comsubs_output_section(res)
    p = findall(x->occursin("------------",x),res)
    if length(p)==0
        @info "Program comsubs didn't finished."
        return [res,]
    elseif length(p)==1
        @info "Program comsubs didn't find any common subgroups."
    end
    ps = [1, (p.+1)...]
    pe = [(p.-1)..., length(res)]
    return Vector{String}[res[i:j] for (i,j) ∈ zip(ps,pe)]
end


function comsubs_output_subgroup(sect)
    p1 = findfirst(x->occursin("Setting of crystal 1:",x), sect)
    p2 = findfirst(x->occursin("Setting of crystal 2:",x), sect)
    pm = findfirst(x->occursin("At midpoint:",x), sect)
    
    dic = Dict()
    dic["Subgroup"] = replace(sect[1], r"Subgroup\s+"=>"")

    for i=2:p1-1
        (k,v) = split(sect[i],":",keepempty=false)
        dic[strip(k)] = strip(v)
    end

    cryst1 = Dict()
    (k,v) = split(sect[p1+1],"=",keepempty=false)
    cryst1[strip(k)] = strip(v)
    for i=p1+2:p1+4
        (k,v) = split(sect[i],":",keepempty=false)
        cryst1[strip(k)] = strip(v)
    end
    cryst1["Wyckoff"] = STRPRM(sect[p1+5:p2-1])
    dic["Crystal 1"] = cryst1

    cryst2 = Dict()
    (k,v) = split(sect[p2+1],"=",keepempty=false)
    cryst2[strip(k)] = strip(v)
    for i=p2+2:p2+4
        (k,v) = split(sect[i],":",keepempty=false)
        cryst2[strip(k)] = strip(v)
    end
    cryst2["Wyckoff"] = STRPRM(sect[p2+5:pm-1])
    dic["Crystal 2"] = cryst2

    crystm = Dict()
    (k,v) = split(sect[pm+1],":",keepempty=false)
    crystm[strip(k)] = strip(v)
    crystm["Wyckoff"] = STRPRM(sect[pm+2:end])
    dic["Crystal m"] = crystm

    return dic
end


@inline comsubs_output_issubgroup(sect) = (length(sect)>0 && occursin(r"Subgroup\s+\d+",sect[1]))


@inline comsubs_output_isfinished(res) = (length(res)>0 && findfirst(x->occursin(r"done",x),res)!==nothing)


comsubs_output_subgroups(res) = [   comsubs_output_subgroup(s) 
                                        for s in comsubs_output_section(res) 
                                            if comsubs_output_issubgroup(s)    ]


default_score_function = ((stress3,size2)->sum(abs.(stress3.-1))*(10max(size2...)))


function comsubs_output_subgroup_score(
    sg::Dict; 
    score_func=default_score_function
    )
    stress = parse_3_float64(sg["Principal values of strain tensor"])
    min_d  = parse_number(sg["Nearest-neighbor distance along path"])
    size1  = parse_number(sg["Crystal 1"]["Size"])
    size2  = parse_number(sg["Crystal 2"]["Size"])
    #! arbitrary scoring function ....
    score = score_func(stress,(size1,size2))
    return score
end


function comsubs_output_subgroup_scores(
    subg::Vector{D};
    score_func=default_score_function
    ) where { D<:Dict }
    return [comsubs_output_subgroup_score(x, score_func=score_func) for x in subg]
end


function comsubs_output_subgroup_scores(
    res::Vector{S};
    score_func=default_score_function
    ) where { S<:AbstractString }
    subg = comsubs_output_subgroups(res)
    comsubs_output_subgroup_scores(subg, score_func=score_func)
end


function comsubs_output_min_score(
    subg_or_res;
    score_func=default_score_function
    )
    return minimum(comsubs_output_subgroup_scores(subg_or_res, score_func=score_func))
end


function comsubs_output_info(res)
    sect1 = first(comsubs_output_section(res))
    p1 = findfirst(x->occursin("First crystal:",x), sect1)
    p2 = findfirst(x->occursin("Second crystal:",x), sect1)
    pm = findfirst(x->occursin("Minimum size of unit cell:",x), sect1)

    dic = Dict()

    cryst1 = Dict()
    i = 1
    for i=p1+1:p2-1
        if !occursin(":",sect1[i])
            break
        end
        (k,v) = split(sect1[i],":",keepempty=false)
        cryst1[strip(k)] = strip(v)
    end
    cryst1["Wyckoff"] = STRPRM(sect1[i:p2-1])
    dic["First crystal"] = cryst1

    cryst2 = Dict()
    i = 1
    for i=p2+1:pm-1
        if !occursin(":",sect1[i])
            break
        end
        (k,v) = split(sect1[i],":",keepempty=false)
        cryst2[strip(k)] = strip(v)
    end
    cryst2["Wyckoff"] = STRPRM(sect1[i:pm-1])
    dic["Second crystal"] = cryst2

    for i=pm+1:length(sect1)
        if occursin(":",sect1[i])
            (k,v) = split(sect1[i],":",keepempty=false)
            dic[strip(k)] = strip(v)
        end
    end

    return dic
end


function comsubs_output_wyckoff_to_atomlist(wyckoff, SG::Int)
    W_SG = get_Wyckoff_all_std_setting(SG)
    atom_list = []
    strip_brackets(s) = strip(s, ['(',')'])
    @inline findxyz(l,op) = eval(Meta.parse(join([l; op],"; ")))
    for wline in wyckoff
        wyck = SPLTS(replace(replace(wline,r"\s*\=\s+"=>"="),","=>" ")) ##!! CAREFUUUL !!!
        atom_symbol     = wyck[1]
        wyckoff_symbol  = wyck[2]
        wyckoff_params0 = length(wyck)==2 ? [] : wyck[3:end]
        wyckoff_params  = map(x->(replace(x,"\'"=>"")), wyckoff_params0)
        wyckoff_ops     = get_Wyckoff_ops_std_setting(SG, wyckoff_symbol, W_SG)
        (x, y, z) = findxyz(wyckoff_params, wyckoff_ops[1])
        # (@sprintf  "%s  %s  %s  %12.8f  %12.8f  %12.8f  1.00000"  a*string(i)  a  w  x  y  z)
        #  O1  O  f 0.50000 0.00000 0.00000 1.00000
        push!(atom_list, (atom_symbol, wyckoff_symbol, x, y, z))
    end
    return atom_list
end


function comsubs_output_cryst_to_cif(dic::Dict)
    ID  = dic["Subgroup"]
    SG  = parse_number( SPLTS(dic["Common subgroup"])[1] )
    strip_brackets(s) = strip(s, ['(',')'])
    OPS = strip_brackets.(get_Wyckoff_ops_for_general_xyz_std_setting(SG))

    cif1 = cif_with_symmetry_ops(   "[COMSUBS output] Subgroup $ID Crystal 1", 
                                    Tuple((parse_6f(dic["Crystal 1"]["Lattice parameters"])..., SG)), 
                                    comsubs_output_wyckoff_to_atomlist(dic["Crystal 1"]["Wyckoff"], SG),
                                    OPS    )

    cif2 = cif_with_symmetry_ops(   "[COMSUBS output] Subgroup $ID Crystal 2", 
                                    Tuple((parse_6f(dic["Crystal 2"]["Lattice parameters"])..., SG)), 
                                    comsubs_output_wyckoff_to_atomlist(dic["Crystal 2"]["Wyckoff"], SG),
                                    OPS    )

    cifm = cif_with_symmetry_ops(   "[COMSUBS output] Subgroup $ID Crystal m", 
                                    Tuple((parse_6f(dic["Crystal m"]["Lattice parameters"])..., SG)), 
                                    comsubs_output_wyckoff_to_atomlist(dic["Crystal m"]["Wyckoff"], SG),
                                    OPS    )

    return cif1, cif2, cifm
end


function comsubs_output_cryst_to_cif(sect::Vector{S}) where {S<:AbstractString}
    comsubs_output_cryst_to_cif(comsubs_output_subgroup(sect))
end


function comsubs_output_low_score_subgroups_to_cif(
    res, 
    out_fd::String, 
    max_score::Float64, 
    score_func=((strss3,sz2)->sum(abs.(strss3.-1))*(10max(sz2...)))
    )
    subgroups = comsubs_output_subgroups(res)
    scores    = comsubs_output_subgroup_scores(subgroups, score_func=score_func)
    maxs      = (max_score>1e-5) ? max_score : minimum(scores)+1e-5
    fd = rstrip(out_fd,"/")
    for (i, x) in enumerate(zip(subgroups,scores))
        (sg, n) = x
        if n < maxs
            (c1,c2,cm) = comsubs_output_cryst_to_cif(sg)
            c1 ⇶ "$fd/sub.$(i).1.cif"
            c2 ⇶ "$fd/sub.$(i).2.cif"
            cm ⇶ "$fd/sub.$(i).m.cif"
        end
    end
    return
end


#! used to be SPT_path()
function comsubs_output_path_cifs(comsubs_res_fn; mid_points=[0.5,])
    closef(f1,f2) = abs(f1-f2)<1e-4
    res  = readlines(comsubs_res_fn)
    subgroups = comsubs_output_subgroups(res)
    scores    = comsubs_output_subgroup_scores(subgroups)
    commsg    = [strip(sg["Common subgroup"]) for sg in subgroups]
    commsg_unique = unique(commsg)
    pick(x) = [(sg,csg,sc) for (sg,csg,sc) in zip(subgroups,commsg,scores) if csg==x]
    commsg_minscore = [ first(sort(pick(csg0),by=last)) for csg0 in commsg_unique ]

    # for each representatives
    all_cifs = []
    for (sg, csg, sc) in commsg_minscore
        (c1,  c2, cm) = comsubs_output_cryst_to_cif(sg)
        cifs = [(c1,0.0), (cm,0.5), (c2,1.0)]
        for λk in mid_points
            if closef(λk,1//2) || closef(λk,0) || closef(λk,1)
                nothing
            elseif λk>1//2+5e-5
                cx = interpolate_cif(SPLTN(cm), SPLTN(c2), λ=2*(λk-1//2))
                push!(cifs, (cx,λk))
            else
                cx = interpolate_cif(SPLTN(c1), SPLTN(cm), λ=2*(λk-0//2))
                push!(cifs, (cx,λk))
            end
        end
        push!(all_cifs, (csg, cifs))
    end
    return all_cifs
end


function comsubs_output_ALL_path_cifs(comsubs_res_fn; mid_points=[0.5,])
    closef(f1,f2) = abs(f1-f2)<1e-4
    res  = readlines(comsubs_res_fn)
    subgroups = comsubs_output_subgroups(res)
    commsg    = [strip(sg["Common subgroup"]) for sg in subgroups]
    # for each subgroup
    all_cifs = []
    i = 1
    for (sg, csg) in zip(subgroups,commsg)
        (c1, c2, cm) = comsubs_output_cryst_to_cif(sg)
        cifs = []
        for λk in mid_points
            if closef(λk,1//2)
                push!(cifs, (cm,0.5))
            elseif closef(λk,0)
                push!(cifs, (c1,0.0))
            elseif closef(λk,1)
                push!(cifs, (c2,1.0))
            elseif λk>1//2+5e-5
                cx = interpolate_cif(SPLTN(cm), SPLTN(c2), λ=2*(λk-1//2))
                push!(cifs, (cx,λk))
            else
                cx = interpolate_cif(SPLTN(c1), SPLTN(cm), λ=2*(λk-0//2))
                push!(cifs, (cx,λk))
            end
        end
        push!(all_cifs, (i, csg, cifs))
        i += 1
    end
    return all_cifs
end
